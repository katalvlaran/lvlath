// Package builder provides concrete GraphConstructor factories for common topologies.
// Each constructor is idempotent, thread-safe (leveraging core.Graph’s internal locks),
// validates its parameters, respects graph configuration (directed, weighted, loops, multi-edges),
// and returns rich, wrapped errors for diagnostics.
//
// The package offers builders for:
//   - Cycle
//   - Path
//   - Star
//   - Wheel
//   - Complete graph
//   - Complete bipartite
//   - Erdős–Rényi random sparse
//   - Random regular
//   - 2D grid
//   - Hexagram (Star-of-David variants)
//   - Platonic solids (Tetrahedron, Cube, Octahedron, Dodecahedron, Icosahedron)
package builder

import (
	"fmt"

	"github.com/katalvlaran/lvlath/core"
)

// GraphConstructor is a function that populates the provided graph g with
// vertices and edges for a specific topology. It must obey the following:
//
//   - Validate all input parameters before mutating g.
//   - Respect g’s configuration:
//     – g.Directed(): default directedness
//     – g.Weighted(): allow non-zero weights
//     – g.Looped(): allow self-loops
//     – g.MultiEdges(): allow parallel edges
//   - Produce no duplicates: idempotent on a fresh graph.
//   - Wrap all errors using builderErrorf with context tokens.
//   - Be safe under concurrent use of core.Graph methods.
//
// Parameters:
//
//	– g: *core.Graph to populate.
//
// Returns:
//
//	– error: non-nil if validation or core operations fail.
type GraphConstructor func(g *core.Graph) error

// BuildGraph creates a new core.Graph configured by opts, then applies ctor
// to populate it. Errors from ctor are wrapped with “BuildGraph” context.
//
// Parameters:
//
//	– opts: slice of core.GraphOption (e.g., core.WithWeighted(), core.WithDirected()).
//	– ctor: GraphConstructor to invoke.
//
// Returns:
//
//	– *core.Graph: fully constructed graph, if no errors.
//	– error: wrapped error, if ctor returns non-nil.
//
// Errors:
//   - fmt.Errorf("BuildGraph: %w", err) // wrapping ctor’s error.
//
// Complexity:
//   - O(V+E) time and O(1) space, dominated by ctor’s operations.
func BuildGraph(opts []core.GraphOption, ctor GraphConstructor) (*core.Graph, error) {
	g := core.NewGraph(opts...)
	if err := ctor(g); err != nil {
		return nil, fmt.Errorf("BuildGraph: %w", err)
	}
	return g, nil
}

// Cycle returns a GraphConstructor that builds an n‐vertex cycle (ring).
// You may supply BuilderOption(s) to customize weight distribution, RNG seed, or vertex‐ID scheme.
// Vertices 0…n−1 are connected by edges i→(i+1)%n.
//
// Parameters:
//
//	– n: number of vertices, must be ≥ MinCycleNodes.
//	– opts: BuilderOption(s) to override RNG, WeightFn, IDFn.
//
// Returns:
//
//	– GraphConstructor: use with BuildGraph.
//
// Errors:
//   - validateMin(MethodCycle, n, MinCycleNodes) if n too small.
//   - builderErrorf(MethodCycle, "AddVertex/AddEdge: %v", err) on core failures.
//
// Idempotence:
//   - Safe to call repeatedly on a fresh graph.
//
// Thread-safety:
//   - Relies on core.Graph’s internal sync.RWMutex.
//
// Complexity:
//   - O(n) time, O(1) extra space.
//
// See:
//   - MethodCycle, MinCycleNodes, WithSeed, WithSymbolIDs, WithUniformWeight.
func Cycle(n int, opts ...BuilderOption) GraphConstructor {
	return func(g *core.Graph) error {
		// Assemble configuration from options (weightFn, rng, idFn)
		cfg := newBuilderConfig(opts...)

		// Validate that n meets minimum cycle size
		if err := validateMin(MethodCycle, n, MinCycleNodes); err != nil {
			return err
		}

		// Add all n vertices (IDs generated by cfg.idFn)
		if err := addSequentialVertices(g, n); err != nil {
			return err
		}

		// Predeclared loop variables for reuse
		var (
			u, v   string // source and target vertex IDs
			weight int64  // sampled edge weight
			err    error  // error placeholder
			i      int    // loop iterator
		)

		// Build the ring: for each i, connect i → (i+1)%n
		for i = 0; i < n; i++ {
			u = cfg.idFn(i)                // compute source ID
			v = cfg.idFn((i + 1) % n)      // compute target ID
			weight = cfg.weightFn(cfg.rng) // sample weight via configured RNG
			if _, err = g.AddEdge(u, v, weight); err != nil {
				// wrap with uniform builder context
				return builderErrorf(MethodCycle, "AddEdge(%s→%s,w=%d): %v", u, v, weight, err)
			}
		}

		return nil
	}
}

// Path returns a GraphConstructor that builds an n‐vertex simple path.
// You may supply BuilderOption(s) to customize weight distribution, RNG seed, or vertex‐ID scheme.
// Vertices connected by edges (i-1)→i for i in [1,n).
//
// Parameters:
//
//	– n: number of vertices, must be ≥ MinPathNodes.
//	– opts: BuilderOption(s) for RNG, weights, IDs.
//
// Returns:
//
//	– GraphConstructor.
//
// Errors:
//   - validateMin(MethodPath, n, MinPathNodes).
//   - builderErrorf(MethodPath, "..."): core.AddVertex/AddEdge errors.
//
// Idempotence:
//   - No duplicates on fresh graph.
//
// Complexity:
//   - O(n) time, O(1) space.
//
// See:
//   - MethodPath, MinPathNodes, WithSeed, WithSymbolIDs, WithUniformWeight.
func Path(n int, opts ...BuilderOption) GraphConstructor {
	return func(g *core.Graph) error {
		// Assemble configuration from options (weightFn, rng, idFn)
		cfg := newBuilderConfig(opts...)

		// Validate that n meets minimum path size
		if err := validateMin(MethodPath, n, MinPathNodes); err != nil {
			return err
		}

		// Add all n vertices (IDs generated by cfg.idFn)
		if err := addSequentialVertices(g, n); err != nil {
			return err
		}

		// Predeclared loop variables for reuse
		var (
			u, v   string
			weight int64
			err    error
			i      int
		)

		// Build the path: for each i in [1..n-1], connect (i-1) → i
		for i = 1; i < n; i++ {
			u = cfg.idFn(i - 1)            // compute source ID
			v = cfg.idFn(i)                // compute target ID
			weight = cfg.weightFn(cfg.rng) // sample weight via configured RNG
			if _, err = g.AddEdge(u, v, weight); err != nil {
				// wrap with uniform builder context
				return builderErrorf(MethodPath, "AddEdge(%s→%s,w=%d): %v", u, v, weight, err)
			}
		}

		return nil
	}
}

// Star returns a GraphConstructor that builds a star topology of n vertices.
// You may supply BuilderOption(s) to customize weight distribution, RNG seed, or vertex‐ID scheme.
// A central hub at CenterVertexID connects to leaves idFn(1)…idFn(n-1).
//
// Parameters:
//
//	– n: total vertices, must be ≥ MinStarNodes.
//	– opts: BuilderOption(s) for RNG, weights, IDs.
//
// Returns:
//
//	– GraphConstructor.
//
// Errors:
//   - validateMin(MethodStar, n, MinStarNodes).
//   - builderErrorf(MethodStar, "AddVertex/AddEdge: %v", err).
//
// Idempotence & Thread-safety: as above.
//
// Complexity:
//   - O(n) time, O(1) space.
//
// See:
//   - MethodStar, MinStarNodes, WithSeed, WithSymbolIDs, WithUniformWeight.
func Star(n int, opts ...BuilderOption) GraphConstructor {
	return func(g *core.Graph) error {
		// Assemble builder configuration from options
		cfg := newBuilderConfig(opts...)

		// Validate that n meets minimum star size
		if err := validateMin(MethodStar, n, MinStarNodes); err != nil {
			return err
		}

		// Add hub vertex
		if err := g.AddVertex(CenterVertexID); err != nil {
			return builderErrorf(MethodStar, "AddVertex(%s): %v", CenterVertexID, err)
		}

		// Predeclared loop variables for reuse
		var (
			leafID string // ID for each leaf vertex
			weight int64  // sampled edge weight
			err    error  // error placeholder
			i      int    // loop iterator
		)

		// Add each leaf and connect it to the hub
		for i = 1; i < n; i++ {
			leafID = cfg.idFn(i) // compute leaf ID using idFn
			if err = g.AddVertex(leafID); err != nil {
				return builderErrorf(MethodStar, "AddVertex(%s): %v", leafID, err)
			}

			weight = cfg.weightFn(cfg.rng) // sample weight via configured RNG
			if _, err = g.AddEdge(CenterVertexID, leafID, weight); err != nil {
				return builderErrorf(MethodStar, "AddEdge(%s→%s,w=%d): %v", CenterVertexID, leafID, weight, err)
			}
		}

		return nil
	}
}

// Wheel returns a GraphConstructor that builds an n-vertex wheel.
// It first draws Cycle(n), then adds a hub CenterVertexID and spokes.
// You may supply BuilderOption(s) to customize weight distribution, RNG seed, or vertex‐ID scheme.
//
// Parameters:
//
//	– n: cycle size, must be ≥ MinWheelNodes.
//	– opts: BuilderOption(s).
//
// Returns:
//
//	– GraphConstructor.
//
// Errors:
//   - validateMin(MethodWheel, n, MinWheelNodes).
//   - base cycle errors wrapped with MethodWheel.
//   - AddVertex/AddEdge errors.
//
// Complexity:
//   - O(n) time, O(1) space.
//
// See:
//   - MethodWheel, MinWheelNodes, WithSeed, WithSymbolIDs, WithUniformWeight.
func Wheel(n int, opts ...BuilderOption) GraphConstructor {
	return func(g *core.Graph) error {
		// Assemble builder configuration from options
		cfg := newBuilderConfig(opts...)

		// Validate that n meets minimum wheel size
		if err := validateMin(MethodWheel, n, MinWheelNodes); err != nil {
			return err
		}

		// Build the outer cycle using the same options
		if err := Cycle(n, opts...)(g); err != nil {
			return builderErrorf(MethodWheel, "base cycle: %v", err)
		}

		// Add hub vertex
		if err := g.AddVertex(CenterVertexID); err != nil {
			return builderErrorf(MethodWheel, "AddVertex(%s): %v", CenterVertexID, err)
		}

		// Predeclare loop variables for reuse
		var (
			vid    string // cycle vertex ID
			weight int64  // sampled edge weight
			err    error  // error placeholder
			i      int    // loop iterator
		)

		// Connect hub to each cycle vertex
		for i = 0; i < n; i++ {
			vid = cfg.idFn(i)              // compute cycle vertex ID
			weight = cfg.weightFn(cfg.rng) // sample weight via configured RNG
			if _, err = g.AddEdge(CenterVertexID, vid, weight); err != nil {
				return builderErrorf(MethodWheel, "AddEdge(%s→%s,w=%d): %v", CenterVertexID, vid, weight, err)
			}
		}

		return nil
	}
}

// Complete returns a GraphConstructor that builds the complete graph on n vertices.
// You may supply BuilderOption(s) to customize weight distribution, RNG seed, or vertex‐ID scheme.
// Every pair of distinct vertices is joined by an edge (and its reverse if directed).
// Idempotent: re-running will not duplicate vertices or edges.
//
// Parameters:
//
//	– n: vertex count, must be ≥ 1.
//	– opts: BuilderOption(s).
//
// Returns:
//
//	– GraphConstructor.
//
// Errors:
//   - validateMin(MethodComplete, n, 1).
//   - builderErrorf(MethodComplete, "...") on core errors.
//
// Complexity:
//   - O(n²) time, O(n) space for ID slice.
//
// See:
//   - MethodComplete, WithSeed, WithSymbolIDs, WithUniformWeight.
//
// Notes:
//
//	– Mirrors edges only when g.Directed()==true.
func Complete(n int, opts ...BuilderOption) GraphConstructor {
	return func(g *core.Graph) error {
		// Assemble builder configuration from options
		cfg := newBuilderConfig(opts...)

		// Validate that n ≥ 1
		if err := validateMin(MethodComplete, n, 1); err != nil {
			return err
		}

		// Preallocate ID slice and add all vertices
		ids := make([]string, n)
		var i int // loop iterator
		for i = 0; i < n; i++ {
			ids[i] = cfg.idFn(i) // generate vertex ID
			if err := g.AddVertex(ids[i]); err != nil {
				return builderErrorf(MethodComplete, "AddVertex(%s): %v", ids[i], err)
			}
		}

		// Predeclared loop variables for reuse
		var (
			u, v   string // endpoints
			weight int64  // sampled weight
			err    error  // error placeholder
			j      int    // loop iterator
		)

		// Connect every unordered pair {u,v}
		for i = 0; i < n; i++ {
			u = ids[i]
			for j = i + 1; j < n; j++ {
				v = ids[j]
				weight = cfg.weightFn(cfg.rng) // sample weight
				if _, err = g.AddEdge(u, v, weight); err != nil {
					return builderErrorf(MethodComplete, "AddEdge(%s→%s,w=%d): %v", u, v, weight, err)
				}
				// mirror if directed
				if g.Directed() {
					if _, err = g.AddEdge(v, u, weight); err != nil {
						return builderErrorf(MethodComplete, "AddEdge(%s→%s,w=%d): %v", v, u, weight, err)
					}
				}
			}
		}

		return nil
	}
}

// CompleteBipartite returns a GraphConstructor for the complete bipartite graph K_{n1,n2}.
// You may supply BuilderOption(s) to customize weight distribution, RNG seed, or vertex‐ID scheme.
// It creates n1 “L” vertices and n2 “R” vertices, then connects every L to every R.
// Directed graphs also include the reverse connections.
//
// Parameters:
//
//	– n1, n2: partition sizes ≥1 (validatePartition).
//	– opts: BuilderOption(s).
//
// Returns:
//
//	– GraphConstructor.
//
// Errors:
//   - validatePartition(MethodCompleteBipartite, n1, n2).
//   - builderErrorf for AddVertex/AddEdge failures.
//
// Idempotence:
//   - re-running does not duplicate vertices or edges.
//
// Complexity:
//   - O(n1·n2) time, O(n1+n2) space.
func CompleteBipartite(n1, n2 int, opts ...BuilderOption) GraphConstructor {
	return func(g *core.Graph) error {
		// 1. Assemble builder configuration from options
		cfg := newBuilderConfig(opts...)

		// 2. Validate partition sizes
		if err := validatePartition(MethodCompleteBipartite, n1, n2); err != nil {
			return err
		}

		// 3. Preallocate ID slices and add left partition
		leftIDs := make([]string, n1)
		var i int // loop iterator
		for i = 0; i < n1; i++ {
			leftIDs[i] = vertexID("L", i) // e.g. "L0"
			if err := g.AddVertex(leftIDs[i]); err != nil {
				return builderErrorf(MethodCompleteBipartite,
					"AddVertex(%s): %v", leftIDs[i], err)
			}
		}

		// Add right partition
		rightIDs := make([]string, n2)
		var j int // loop iterator
		for j = 0; j < n2; j++ {
			rightIDs[j] = vertexID("R", j) // e.g. "R0"
			if err := g.AddVertex(rightIDs[j]); err != nil {
				return builderErrorf(MethodCompleteBipartite, "AddVertex(%s): %v", rightIDs[j], err)
			}
		}

		// Predeclared loop variables for reuse
		var (
			u, v   string
			weight int64
			err    error
		)

		// Connect each left to each right (and mirror if directed)
		for _, u = range leftIDs {
			for _, v = range rightIDs {
				weight = cfg.weightFn(cfg.rng) // sample weight
				// Add edge u -> v
				if _, err = g.AddEdge(u, v, weight); err != nil {
					return builderErrorf(MethodCompleteBipartite, "AddEdge(%s→%s,w=%d): %v", u, v, weight, err)
				}
				// If directed, also add v -> u
				if g.Directed() {
					if _, err = g.AddEdge(v, u, weight); err != nil {
						return builderErrorf(MethodCompleteBipartite, "AddEdge(%s→%s,w=%d): %v", v, u, weight, err)
					}
				}
			}
		}

		return nil
	}
}

// RandomSparse returns a GraphConstructor that builds an Erdős–Rényi G(n,p) random graph.
// You may supply BuilderOption(s) to customize weight distribution, RNG seed, or vertex‐ID scheme.
// Each potential edge is included with probability p; self‐loops only if g.Looped()==true.
// Undirected: unordered pairs i<j; Directed: all pairs i,j. Directed graphs sample ordered pairs;
// Self-loops only if g.Looped()==true.
//
// Parameters:
//
//	– n: vertex count ≥1.
//	– p: probability in [0,1] (validateProbability).
//	– opts: BuilderOption(s); RNG required or returns error.
//
// Returns:
//
//	– GraphConstructor.
//
// Errors:
//   - validateMin(MethodRandomSparse, n, 1).
//   - validateProbability(MethodRandomSparse, p).
//   - builderErrorf(MethodRandomSparse, "rng must be non-nil") if no RNG.
//   - builderErrorf(MethodRandomSparse, "..."): core errors.
//
// Idempotence:
//   - re-running does not duplicate vertices or edges.
//
// Complexity:
//   - O(n²) time, O(1) space.
func RandomSparse(n int, p float64, opts ...BuilderOption) GraphConstructor {
	return func(g *core.Graph) error {
		// Assemble builder configuration from options
		cfg := newBuilderConfig(opts...)

		// Validate minimum vertices
		if err := validateMin(MethodRandomSparse, n, 1); err != nil {
			return err
		}
		// Validate probability parameter
		if err := validateProbability(MethodRandomSparse, p); err != nil {
			return err
		}
		// Ensure RNG is provided (for reproducibility/randomness)
		if cfg.rng == nil {
			return builderErrorf(MethodRandomSparse, "rng must be non-nil")
		}
		// Add all n vertices
		if err := addSequentialVertices(g, n); err != nil {
			return err
		}

		// Predeclare loop variables for reuse
		var (
			u, v    string // endpoint IDs
			weight  int64  // sampled weight
			randSrc = cfg.rng
			err     error
			i, j    int // loop iterator
		)

		// Sample edges per graph directedness
		if g.Directed() {
			// Directed: i → j for all i,j
			for i = 0; i < n; i++ {
				u = cfg.idFn(i)
				for j = 0; j < n; j++ {
					// skip self-loop if disallowed
					if i == j && !g.Looped() {
						continue
					}
					if randSrc.Float64() <= p {
						v = cfg.idFn(j)
						weight = cfg.weightFn(randSrc)
						if _, err = g.AddEdge(u, v, weight); err != nil {
							return builderErrorf(MethodRandomSparse, "AddEdge(%s→%s,w=%d): %v", u, v, weight, err)
						}
					}
				}
			}
		} else {
			// Undirected: each unordered pair {i,j}, i<j
			for i = 0; i < n; i++ {
				u = cfg.idFn(i)
				for j = i + 1; j < n; j++ {
					if randSrc.Float64() <= p {
						v = cfg.idFn(j)
						weight = cfg.weightFn(randSrc)
						if _, err = g.AddEdge(u, v, weight); err != nil {
							return builderErrorf(MethodRandomSparse, "AddEdge(%s→%s,w=%d): %v", u, v, weight, err)
						}
					}
				}
			}
		}

		return nil
	}
}

// RandomRegular returns a GraphConstructor that builds an undirected d‐regular graph.
// You may supply BuilderOption(s) to customize weight distribution, RNG seed, or vertex‐ID scheme.
// Uses stub-matching with shuffle; allows loops/multi-edges per g.Options().
//
// Parameters:
//
//	– n: vertex count ≥1.
//	– degree: 0≤degree<n and (n·degree)%2==0.
//	– opts: BuilderOption(s); RNG required.
//
// Returns:
//
//	– GraphConstructor.
//
// Errors:
//   - validateMin(MethodRandomRegular, n, 1).
//   - builderErrorf(MethodRandomRegular, "degree must be in ...").
//   - Error if g.Directed()==true.
//   - Error if no RNG.
//
// Complexity:
//   - O(n·degree) expected time and space.
func RandomRegular(n, degree int, opts ...BuilderOption) GraphConstructor {
	return func(g *core.Graph) error {
		// Assemble builder configuration from options
		cfg := newBuilderConfig(opts...)

		// Must be undirected
		if g.Directed() {
			return builderErrorf(MethodRandomRegular, "only supports undirected graphs")
		}
		// Validate parameters: n≥1, 0≤degree<n, and n·degree even
		if err := validateMin(MethodRandomRegular, n, 1); err != nil {
			return err
		}
		if degree < 0 || degree >= n {
			return builderErrorf(MethodRandomRegular, "degree must be in [0,%d), got %d", n, degree)
		}
		if (n*degree)%2 != 0 {
			return builderErrorf(MethodRandomRegular, "n·degree must be even, got n=%d, degree=%d", n, degree)
		}
		// Ensure RNG is provided
		if cfg.rng == nil {
			return builderErrorf(MethodRandomRegular, "rng must be non-nil")
		}

		// Add all n vertices
		if err := addSequentialVertices(g, n); err != nil {
			return err
		}

		// Build and shuffle stub list
		stubCount := n * degree
		stubs := make([]int, stubCount)
		var i, j int // loop iterator
		for i = 0; i < n; i++ {
			for j = 0; j < degree; j++ {
				stubs[i*degree+j] = i
			}
		}
		cfg.rng.Shuffle(stubCount, func(a, b int) {
			stubs[a], stubs[b] = stubs[b], stubs[a]
		})

		// Predeclare loop variables
		var (
			idx, uIdx, vIdx int
			u, v            string
			weight          int64
			err             error
		)

		// Pair stubs and add edges
		for idx = 0; idx < stubCount; idx += 2 {
			uIdx = stubs[idx]
			vIdx = stubs[idx+1]
			// skip self-loop if disallowed
			if uIdx == vIdx && !g.Looped() {
				continue
			}
			u = cfg.idFn(uIdx)
			v = cfg.idFn(vIdx)
			weight = cfg.weightFn(cfg.rng)
			if _, err = g.AddEdge(u, v, weight); err != nil {
				return builderErrorf(MethodRandomRegular, "AddEdge(%s→%s,w=%d): %v", u, v, weight, err)
			}
		}

		return nil
	}
}

// Grid returns a GraphConstructor that builds a 2D grid of size rows×cols.
// You may supply BuilderOption(s) to customize weight distribution, RNG seed, or vertex-ID scheme.
// Each vertex is identified by "r,c" (via gridVertexID). Edges connect right and bottom neighbors,
// sampling weights per edge. Directed graphs mirror edges if configured.
//
// Parameters:
//
//	– rows, cols: dimensions ≥ MinGridDim.
//	– opts: BuilderOption(s).
//
// Returns:
//
//	– GraphConstructor.
//
// Errors:
//   - validateMin(MethodGrid, rows, MinGridDim).
//   - validateMin(MethodGrid, cols, MinGridDim).
//   - builderErrorf(MethodGrid, "..."): core errors.
//
// Complexity:
//   - O(rows*cols) time, O(1) space.
//
// See:
//   - MethodGrid, MinGridDim, WithSeed, WithSymbolIDs, WithUniformWeight.
func Grid(rows, cols int, opts ...BuilderOption) GraphConstructor {
	return func(g *core.Graph) error {
		// Assemble builder configuration from options
		cfg := newBuilderConfig(opts...)

		// Validate that both dimensions meet the minimum
		if err := validateMin(MethodGrid, rows, MinGridDim); err != nil {
			return err
		}
		if err := validateMin(MethodGrid, cols, MinGridDim); err != nil {
			return err
		}

		// Predeclare loop variables for reuse
		var (
			r, c     int    // grid coordinates
			id, u, v string // vertex IDs
			weight   int64  // sampled edge weight
			err      error  // error placeholder
		)

		// 4) Add all vertices "r,c"
		for r = 0; r < rows; r++ {
			for c = 0; c < cols; c++ {
				id = gridVertexID(r, c) // format "r,c"
				if err = g.AddVertex(id); err != nil {
					return builderErrorf(MethodGrid, "AddVertex(%s): %v", id, err)
				}
			}
		}

		// Connect each cell to its right and bottom neighbor
		for r = 0; r < rows; r++ {
			for c = 0; c < cols; c++ {
				u = gridVertexID(r, c) // source ID

				// Right neighbor at (r, c+1)
				if c+1 < cols {
					v = gridVertexID(r, c+1)       // target ID
					weight = cfg.weightFn(cfg.rng) // sample weight
					if _, err = g.AddEdge(u, v, weight); err != nil {
						return builderErrorf(MethodGrid, "AddEdge(%s→%s,w=%d): %v", u, v, weight, err)
					}
					// mirror for directed graphs
					if g.Directed() {
						if _, err = g.AddEdge(v, u, weight); err != nil {
							return builderErrorf(MethodGrid, "AddEdge(%s→%s,w=%d): %v", v, u, weight, err)
						}
					}
				}

				// Bottom neighbor at (r+1, c)
				if r+1 < rows {
					v = gridVertexID(r+1, c)       // target ID
					weight = cfg.weightFn(cfg.rng) // sample weight again
					if _, err = g.AddEdge(u, v, weight); err != nil {
						return builderErrorf(MethodGrid, "AddEdge(%s→%s,w=%d): %v", u, v, weight, err)
					}
					// mirror for directed graphs
					if g.Directed() {
						if _, err = g.AddEdge(v, u, weight); err != nil {
							return builderErrorf(MethodGrid, "AddEdge(%s→%s,w=%d): %v", v, u, weight, err)
						}
					}
				}
			}
		}

		return nil
	}
}

// Hexagram returns a GraphConstructor that builds a Star-of-David (hexagram) pattern.
// You supply a base weight w and a variant; optional BuilderOption(s) can customize RNG, weight distribution, or ID scheme.
//
// Parameters:
//
//	– variant: HexagramVariant key for sizes & chord sets.
//	– opts: BuilderOption(s).
//
// Returns:
//
//	– GraphConstructor.
//
// Errors:
//   - builderErrorf(MethodHexagram, "unknown variant").
//   - builderErrorf(MethodHexagram, "no chords defined").
//   - core errors via builderErrorf.
//
// Complexity:
//   - O(hSize + |chords|) time, O(1) space.
func Hexagram(variant HexagramVariant, opts ...BuilderOption) GraphConstructor {
	return func(g *core.Graph) error {
		// Assemble builder configuration (weightFn, rng, idFn)
		cfg := newBuilderConfig(opts...)

		// Determine required cycle size for this variant
		hSize, ok := hexSizes[variant]
		if !ok {
			return builderErrorf(MethodHexagram, "unknown variant %v", variant)
		}

		// Build the outer structure: cycle or wheel
		//    - small variants → simple cycle
		//    - large variants → cycle + hub (wheel)
		if variant == HexDefault || variant == HexMedium {
			if err := Cycle(hSize, opts...)(g); err != nil {
				return builderErrorf(MethodHexagram, "base cycle: %v", err)
			}
		} else {
			if err := Wheel(hSize, opts...)(g); err != nil {
				return builderErrorf(MethodHexagram, "base wheel: %v", err)
			}
		}

		// Overlay chords
		chords, ok := hexChordSets[variant]
		if !ok {
			return builderErrorf(MethodHexagram, "no chords defined for variant %v", variant)
		}

		// Predeclare for reuse
		var (
			u, v   string // endpoints
			weight int64  // edge weight
			err    error  // error placeholder
			chord  Chord
		)

		for _, chord = range chords {
			u = cfg.idFn(chord.U) // "0", "1", …
			v = cfg.idFn(chord.V)
			weight = cfg.weightFn(cfg.rng)
			if _, err = g.AddEdge(u, v, weight); err != nil {
				return builderErrorf(MethodHexagram, "AddEdge(%s→%s,w=%d): %v", u, v, weight, err)
			}
			// mirror automatically if directed
		}

		return nil
	}
}

// PlatonicSolid returns a GraphConstructor that builds one of the five Platonic solids.
// You supply the solid name, base weight w, and whether to stellate (withCenter).
// Optional BuilderOption(s) can customize RNG, weights, or ID scheme.
//
// Parameters:
//
//	– name: PlatonicName (Tetrahedron…Icosahedron).
//	– withCenter: add central hub & spokes if true.
//	– opts: BuilderOption(s).
//
// Returns:
//
//	– GraphConstructor.
//
// Errors:
//   - builderErrorf(MethodPlatonicSolid, "unknown solid").
//   - builderErrorf for core.AddVertex/AddEdge failures.
//
// Complexity:
//   - O(V+E) time, O(1) space.
func PlatonicSolid(name PlatonicName, withCenter bool, opts ...BuilderOption) GraphConstructor {
	return func(g *core.Graph) error {
		// Assemble builder configuration
		cfg := newBuilderConfig(opts...)

		// Lookup vertex count
		n, ok := platonicVertexCounts[name]
		if !ok {
			return builderErrorf(MethodPlatonicSolid, "unknown solid %q", name)
		}

		// Add base vertices "0".."n-1"
		if err := addSequentialVertices(g, n); err != nil {
			return builderErrorf(MethodPlatonicSolid, "add vertices: %v", err)
		}

		// Fetch shell-edge list
		edges, ok := platonicEdgeSets[name]
		if !ok {
			return builderErrorf(MethodPlatonicSolid, "no edges defined for %q", name)
		}

		// Predeclare for reuse
		var (
			u, v   string
			weight int64
			err    error
			chord  Chord
			i      int
		)

		// Add each shell edge (and mirror if directed)
		for _, chord = range edges {
			u = cfg.idFn(chord.U)
			v = cfg.idFn(chord.V)
			weight = cfg.weightFn(cfg.rng)

			if _, err = g.AddEdge(u, v, weight); err != nil {
				return builderErrorf(MethodPlatonicSolid, "AddEdge(%s→%s,w=%d): %v", u, v, weight, err)
			}
			if g.Directed() {
				if _, err = g.AddEdge(v, u, weight); err != nil {
					return builderErrorf(MethodPlatonicSolid, "AddEdge(%s→%s,w=%d): %v", v, u, weight, err)
				}
			}
		}

		// Optional stellation: hub + spokes
		if withCenter {
			// add the central vertex
			if err = g.AddVertex(CenterVertexID); err != nil {
				return builderErrorf(MethodPlatonicSolid, "AddVertex(%s): %v", CenterVertexID, err)
			}
			// connect hub to all base vertices
			for i = 0; i < n; i++ {
				v = cfg.idFn(i)
				weight = cfg.weightFn(cfg.rng)

				if _, err = g.AddEdge(CenterVertexID, v, weight); err != nil {
					return builderErrorf(MethodPlatonicSolid,
						"AddEdge(%s→%s,w=%d): %v", CenterVertexID, v, weight, err)
				}
				if g.Directed() {
					if _, err = g.AddEdge(v, CenterVertexID, weight); err != nil {
						return builderErrorf(MethodPlatonicSolid,
							"AddEdge(%s→%s,w=%d): %v", v, CenterVertexID, weight, err)
					}
				}
			}
		}

		return nil
	}
}
